package main

import (
	"context"
	"encoding/csv"
	"log"
	"os"
	"strconv"
	"sync"

	"github.com/gofiber/swagger"

	// docs are generated by Swag CLI
	_ "Fiber_CRUD/docs"

	"github.com/gofiber/fiber/v2"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
)

// Define a struct to represent the data model
type Series struct {
	ID         primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Reference  string             `json:"Reference,omitempty" bson:"Reference,omitempty"`
	Period     string             `json:"Period,omitempty" bson:"Period,omitempty"`
	DataValue  float32            `json:"Data_value,omitempty" bson:"Data_value,omitempty"`
	Suppressed bool               `json:"Suppressed,omitempty" bson:"Suppressed,omitempty"`
	Status     string             `json:"Status,omitempty" bson:"Status,omitempty"`
	Units      string             `json:"Units,omitempty" bson:"Units,omitempty"`
	Magnitude  int32              `json:"Magnitude,omitempty" bson:"Magnitude,omitempty"`
	Subject    string             `json:"Subject,omitempty" bson:"Subject,omitempty"`
	Group      string             `json:"Group,omitempty" bson:"Group,omitempty"`
	Titles     []string           `json:"Titles,omitempty" bson:"Title1,omitempty"`
}

// Define a struct to represent parameters of the swagger
type SwaggerParams struct {
	Reference  string   `json:"Reference,omitempty" bson:"Reference,omitempty"`
	Period     string   `json:"Period,omitempty" bson:"Period,omitempty"`
	DataValue  float32  `json:"Data_value,omitempty" bson:"Data_value,omitempty"`
	Suppressed bool     `json:"Suppressed,omitempty" bson:"Suppressed,omitempty"`
	Status     string   `json:"Status,omitempty" bson:"Status,omitempty"`
	Units      string   `json:"Units,omitempty" bson:"Units,omitempty"`
	Magnitude  int32    `json:"Magnitude,omitempty" bson:"Magnitude,omitempty"`
	Subject    string   `json:"Subject,omitempty" bson:"Subject,omitempty"`
	Group      string   `json:"Group,omitempty" bson:"Group,omitempty"`
	Titles     []string `json:"Titles,omitempty" bson:"Title1,omitempty"`
}

var DB_URI string
var CSV_PATH string

func main() {
	app := fiber.New()

	// Environment variables
	DB_URI = os.Getenv("DB_URI")
	CSV_PATH = os.Getenv("CSV_PATH")

	// Create a MongoDB client
	client, err := mongo.NewClient(options.Client().ApplyURI(DB_URI))
	if err != nil {
		log.Fatal(err)
	}

	// Connect to the MongoDB server
	err = client.Connect(context.Background())
	if err != nil {
		log.Fatal(err)
	}

	// Access the "series" collection in the "WeConnect" database
	seriesCollection := client.Database("WeConnect").Collection("series")

	// Routes
	app.Get("/swagger/*", swagger.HandlerDefault)
	app.Post("/csv-to-mongo", postCSVToMongoDBHandler)

	app.Get("/series", getSeriesHandler(seriesCollection))
	app.Post("/series", postSeriesHandler(seriesCollection))
	app.Delete("/series", deleteSeriesHandler(seriesCollection))

	app.Get("/series/:id", getSingleSeriesHandler(seriesCollection))
	app.Patch("/series/:id", patchSingleSeriesHandler(seriesCollection))
	app.Delete("/series/:id", deleteSingleSeriesHandler(seriesCollection))

	// Start the server
	if err := app.Listen(":3000"); err != nil {
		log.Fatal(err)
	}
}

// @Summary import csv data
// @Description After each time that this endpoint gets called, all of the csv data will be imported to the database.
// @Tags ImportData
// @Produce json
// @Router /csv-to-mongo [post]
func postCSVToMongoDBHandler(c *fiber.Ctx) error {
	// Specify the MongoDB connection details
	clientOptions := options.Client().ApplyURI(DB_URI)

	// Connect to MongoDB
	client, err := mongo.Connect(context.Background(), clientOptions)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Disconnect(context.Background())

	// Ping MongoDB to verify the connection
	err = client.Ping(context.Background(), readpref.Primary())
	if err != nil {
		log.Fatal(err)
	}

	// Specify the MongoDB database and collection
	database := client.Database("WeConnect")
	collection := database.Collection("series")

	// Create a wait group to wait for all goroutines to finish
	var wg sync.WaitGroup

	// Open the CSV file
	file, err := os.Open(CSV_PATH)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}
	defer file.Close()

	// Create a new CSV reader
	reader := csv.NewReader(file)

	// Read the header row (if present)
	_, err = reader.Read()
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Read and insert each row into MongoDB concurrently
	for {
		row, err := reader.Read()
		if err != nil {
			// Check for end-of-file error
			if err.Error() == "EOF" {
				break
			}
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		wg.Add(1) // Increment the wait group counter

		// Execute insertRowsToMongoDB function concurrently
		go func(row []string) {
			defer wg.Done() // Mark goroutine as done when finished

			// Row fields Validation
			var dataValue float32
			var suppressed bool
			if row[2] == "" {
				dataValue = float32(0)
				suppressed = true
			} else {
				value, err := strconv.ParseFloat(row[2], 32)
				if err != nil {
					log.Println(err)
				}
				dataValue = float32(value)
				suppressed = false
			}

			var magnitude int32
			value, err := strconv.ParseInt(row[6], 10, 32)
			if err != nil {
				log.Println(err)
			}
			magnitude = int32(value)

			titles := []string{
				row[9], row[10], row[11], row[12], row[13],
			}

			// Convert and store each value with its corresponding header key
			new_series := Series{
				Reference:  row[0],
				Period:     row[2],
				DataValue:  dataValue,
				Suppressed: suppressed,
				Status:     row[4],
				Units:      row[5],
				Magnitude:  magnitude,
				Subject:    row[7],
				Group:      row[8],
				Titles:     titles,
			}

			// Insert the row data into MongoDB
			_, err = collection.InsertOne(context.Background(), new_series)
			if err != nil {
				log.Println(err)
			}
		}(row)
	}

	// Wait for all goroutines to finish
	wg.Wait()

	return c.SendString("CSV data inserted into MongoDB")
}

// @Summary all the series
// @Description Retrieve list of all the series from series collection
// @Tags Series
// @Produce json
// @Success 200 {array} Series
// @Router /series [get]
func getSeriesHandler(seriesCollection *mongo.Collection) fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Retrieve all series
		cursor, err := seriesCollection.Find(context.Background(), bson.M{})
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}
		defer cursor.Close(context.Background())

		var series []Series
		if err := cursor.All(context.Background(), &series); err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		return c.JSON(series)
	}
}

// @Summary create new series
// @Description Creates a new series using the provided fields.
//
//	Please ensure that the request payload includes only the fields shown in the CSV format.
//	Any additional fields or different field names will be ignored.
//
// @Tags Series
// @Produce json
// @Param series body SwaggerParams true "Series object"
// @Router /series [post]
func postSeriesHandler(seriesCollection *mongo.Collection) fiber.Handler {
	return func(c *fiber.Ctx) error {
		series := new(Series)

		if err := c.BodyParser(series); err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "Invalid request payload: " + err.Error(),
			})
		}

		result, err := seriesCollection.InsertOne(context.Background(), series)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		series.ID = result.InsertedID.(primitive.ObjectID)

		return c.JSON(series)
	}
}

// @Summary delete all of the series
// @Description This endpoint will wipe out the database, and deletes all of the series
// @Tags Series
// @Produce json
// @Router /series [delete]
func deleteSeriesHandler(seriesCollection *mongo.Collection) fiber.Handler {
	return func(c *fiber.Ctx) error {
		_, err := seriesCollection.DeleteMany(context.Background(), bson.D{{}})
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"msg": "seriesCollection is now empty",
		})
	}
}

// @Summary single series
// @Description Get detail of the single series object
// @Tags Series
// @Param id path string true "Series ID"
// @Produce json
// @Success 200 {array} Series
// @Router /series/{id} [get]
func getSingleSeriesHandler(seriesCollection *mongo.Collection) fiber.Handler {
	return func(c *fiber.Ctx) error {
		id, err := primitive.ObjectIDFromHex(c.Params("id"))
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "series id is not valid",
			})
		}

		var series Series
		err = seriesCollection.FindOne(context.Background(), bson.M{"_id": id}).Decode(&series)
		if err != nil {
			if err == mongo.ErrNoDocuments {
				return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
					"error": "series not found",
				})
			}
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		return c.JSON(series)
	}
}

// @Summary update the series fields
// @Description Change any field(except id) of any series
// @Tags Series
// @Produce json
// @Param id path string true "Series ID"
// @Param series body SwaggerParams true "Series object"
// @Router /series/{id} [patch]
func patchSingleSeriesHandler(seriesCollection *mongo.Collection) fiber.Handler {
	return func(c *fiber.Ctx) error {
		series := new(Series)
		if err := c.BodyParser(series); err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "Invalid request payload: " + err.Error(),
			})
		}

		id, err := primitive.ObjectIDFromHex(c.Params("id"))
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "series id is not valid",
			})
		}
		_, err = seriesCollection.UpdateOne(
			context.Background(),
			bson.M{
				"_id": id,
			},
			bson.M{
				"$set": series,
			},
			nil,
		)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "Failed to update you selected id: " + err.Error(),
			})
		}

		series.ID = id
		return c.JSON(series)
	}
}

// @Summary delete a single series object
// @Description Deletes a single series object with the given id
// @Tags Series
// @Produce json
// @Param id path string true "Series ID"
// @Router /series/{id} [delete]
func deleteSingleSeriesHandler(seriesCollection *mongo.Collection) fiber.Handler {
	return func(c *fiber.Ctx) error {
		id, err := primitive.ObjectIDFromHex(c.Params("id"))
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": "series id is not valid",
			})
		}

		status, err := seriesCollection.DeleteOne(context.Background(), bson.M{"_id": id})
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		// check if the object already deleted
		if status.DeletedCount == 1 {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"msg": "id: " + c.Params("id") + ", deleted successfully",
			})
		} else {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
				"msg": "id: " + c.Params("id") + ", already deleted",
			})
		}
	}
}
